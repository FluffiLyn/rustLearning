## 2.3 所有权和借用
与c++手动管理内存和java的GC不同，rust采用了所有权来管理内存。

这种检查仅发生在**编译期**，对于程序的运行时不会有任何性能损失。

### 2.3.1 所有权
基本规则：
* Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
* 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

##### String类型简单介绍
```rs
let s = "abcd";
```
"abcd"是字符串字面值，类型为&str。它的局限性：
* 不可变
* 并非所有字符串的值都能在编写代码时得知

因此，Rs提供动态字符串类型`String`。该类型是被分配到堆上的，因此可以动态伸缩。例如：
```rs
let mut s = String::from("Hello");//将字面值存储在堆上
s.push_str(", world!");//拼接字符串
println!("{}", s);
```

#### 变量绑定背后的数据交互

##### 转移所有权（移动）
```rs
let x = 5;
let y = x;
```
这段代码**并没有发生所有权的转移**，原因： 代码首先将 5 绑定到变量 x，接着拷贝 x 的值赋给 y，最终 x 和 y 都等于 5，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过**自动拷贝**的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。

实际上，rs的基本类型都是通过自动拷贝的方式来赋值的。


```rs
let s1 = String::from("Hello");
let s2 = s1;
```
String并不是基本类型，它由存储在栈中的**堆指针**、**字符串长度**、**字符串容量**共同组成。其中**堆指针**最重要。

对于这一段代码，Rust 这样解决问题：当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，**s1 在被赋予 s2 后就马上失效了**。在这之后再次引用s1，会引发错误。

* 这个操作不是浅拷贝，而是 ***移动（move）***，即拷贝了**堆指针**、**字符串长度**、**字符串容量**（而不拷贝数据）并且使第一个变量失效。

##### 克隆（深拷贝）
Rust所有的**自动复制**均**不是**深拷贝，对运行时性能较小。

Rust提供了一个clone()的方法，能够进行深拷贝操作。

```rs
let s1 = String::from("bruh");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

*如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 clone 来简化编程。但是对于执行较为频繁的代码(热点路径)，使用 clone 会极大的降低程序性能，需要小心使用！*

##### 拷贝（浅拷贝）
浅拷贝只发生在栈上，因此性能很高。
```rs
let x = 5;
let y = x;
println!("x = {}, y = {}", x, y);
```

Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。

那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： 任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。以下是一些Copy的类型
* 所有整数类型，比如 u32
* 布尔类型，bool，它的值是 true 和 false
* 所有浮点数类型，比如 f64
* 字符类型，char
* 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是
* **不可变引用 '&T'** ，例如转移所有权中的最后一个例子，但是注意: **可变引用 &mut T 是不可以 Copy的**

#### 函数传值与返回
将值传递给函数，一样会发生`移动`或者`复制`，如同`let`。

```rs
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

    println!("{}",x);
} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

所有权避免了内存的不安全性。

#### 部分move
当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。

在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。

例如，有这样一个结构体：
```rs
struct Person
{
    name: String,
    age: Box<u8>,
}
```
 创建一个 Person 实例：
```rs
let p = Person 
{
    name: String::from("Alice"),
    age: Box::new(20),
};
```

现在我们想要获取 p 的 name 字段，同时将 p 的 age 字段的所有权转移给另一个变量。我们可以这样做：
```rs
// ref相当于let age = &p.age;，所有权转移给age
let Person { name, ref age } = p;//解构模式匹配
println!("name = {}, age = {}", name, age);
```

以下代码会出错：
```rs
// Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它
println!("The person struct is {:?}", person);
```

然而，以下代码是可以正常运行的：
```rs
// 此时 person 的 name 字段的所有权已经被转移，但是 age 字段的所有权依然在我们手中
println!("The person's age is {}", person.age);
```

### 2.3.2 引用与借用
Rust使用某个变量的指针或者引用的操作，称为`借用（borrowing）`。

#### 引用与解引用
常规引用是一个指针类型，指向了对象存储的内存地址。
```rs
fn main() {
    let x = 5;
    let y = &x;//y是x的引用

    assert_eq!(5, x);
    assert_eq!(5, *y);//解引用
}
```

#### 不可变引用
与变量默认不可变一样，引用指向的值默认也是不可变的。

`&`符号即是引用，它们允许你使用值，但是不获取所有权。当引用离开作用域后，其指向的值也不会被丢弃。

#### 可变引用
在引用的前面加上`mut`关键字，可以创建一个可变引用。

可变引用是
```rs
fn main()
{
    let mut s = String::from("Hello");
    change(&mut s);
}

fn change(s: &mut String)
{
    s.push_str(", world!");
}
```

##### 可变引用的限制
然而，在同一作用域中的特定数据只能有一个可变引用。例如：

```rs
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;
println!("{}, {}", r1, r2);
```
会报错：同一时间无法对 `s` 进行两次可变借用。

原因是：第一个可变借用 r1 必须要持续到最后一次使用的位置 println!，但是我们又创建可变借用r2。

这是Rust编译器的`borrow checker`特性之一，限制的好处就是使 Rust 在编译期就避免**数据竞争**。

<details>
<summary> 
什么是数据竞争？
</summary>

1. 两个或更多的指针同时访问同一数据
   
2. 至少有一个指针被用来写入数据
   
3. 没有同步数据访问的机制
</details> 

可以用大括号手动限制作用域，即可编译通过。
```rs
let mut s = String::from("hello");
{
    let r1 = &mut s;
}
let r2 = &mut s;
```

##### 可变引用与不可变引用不能同时存在
不能同时对一个变量创建可变引用和不可变引用。如：
```rs
let r1 = &s;
let r2 = &mut s;
```
会报错。

在Rust 1.31版本之后，引用作用域的结束位置是**最后一次使用的位置**（而非之前版本的作用域的结束位置）。

#### 悬垂引用（Dangling References）
悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在。

**喜报：Rust永远不会出现悬垂指针，因为编译器可以确保数据不会在引用结束前被释放。**

```rs
fn main()
{
    let ref_to_nothing = dangle();
}
fn dangle() -> &String
{
    let s = String::from("hello");
    &s//返回s的引用
}//s在这里被释放
```
报错：该函数返回了一个借用的值，但是已经找不到它所借用值的来源。

解决方法：返回String而不是String的引用，这样String的所有权就被转移给了调用者。

#### 借用总结
* 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
* 引用必须总是有效的

### 2.3.3 做题笔记
#### &与ref的区别
1. &
   * 在表达式上，表示的是借用。
   * 在变量绑定上，表示解地址操作与*类似。
   * 在类型声明上，表示引用类型。
   * 在模式匹配上，**无效关键字**。
2. ref
   * 在表达式上，**无效关键字**。
   * 在变量绑定上，表示引用类型。
   * 在类型声明上，**无效关键字**。
   * 在模式匹配上，表示引用类型。
   * 
来源：[理解Rust的引用与借用](https://www.jianshu.com/p/ac519d8c5ec9)

#### 从不可变对象获取可变引用
这是错误的。