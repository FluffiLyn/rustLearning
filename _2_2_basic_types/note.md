## 2.2 基本类型

### 2.2.1 数值类型

#### 整数类
* 有符号：i8~i128
* 无符号：u8~u128
isize和usize类型取决于CPU类型。32位cpu下等同于i32和u32，64位同理。

Rust默认用i32，该类型的性能最好。

##### 处理溢出
在使用`--release`参数构建时，Rust**不检测**溢出。

显式处理溢出的方式：
* 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
* 如果使用 checked_* 方法时发生溢出，则返回 None 值
* 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
* 使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:
```rs
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 输出19
}
```

#### 浮点类
* f32和f64（对应单精度和双精度）
* 默认是f64

注意：
* 浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行。

* 浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义。

最经典的，0.1+0.2==0.3返回false;

所以，**避免在浮点数上测试相等性**。

#### NaN
对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。

**所有跟 NaN 交互的操作，都会返回一个 NaN**，而且 NaN 不能用来比较

下面的代码会崩溃：
```rs
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```
出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN。
```rs
if x.nan()  {println!("Undefined");}
```

#### 序列（range）
Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，**不包含 5**；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：
```rs
for i in 1..=5 {
    println!("{}",i);
}
```

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。
```rs
for i in 'a'..='z' {
    println!("{}",i);
}
```

### 2.2.2 字符、布尔、单元类型

#### 字符类型
在rust的字符中，所有的**Unicode值**都可以作为Rust字符。占用4字节。

#### 布尔类型
```rs
fn main() {
    let t = true;

    let f: bool = false; // 使用类型标注,显式指定f的类型

    if f {
        println!("这是段毫无意义的代码");
    }
}
```

#### 单元类型
单元类型就是 `()`。main 函数就返回这个单元类型 ()。

例如常见的 println!() 的返回值也是单元类型 ()；再比如，你可以用 () 作为 map 的值，表示我们不关注具体的值，只关注 key。

不能说 main 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：发散函数( diverge function )，顾名思义，无法收敛的函数。

这种用法和 Go 语言的 struct{} 类似，可以作为一个值用来占位，但是**完全不占用任何内存**。

### 2.2.3 语句与表达式
Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值。

区分**语句（statement）**和**表达式（expression**：
```rs
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```
语句是执行一些操作；表达式是求值后返回一个值。

#### 表达式
调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式。如果表达式“不返回任何值”（包括空的块），会隐式地返回一个`()`。总之，***能返回值，它就是表达式***。

例：
```rs
fn main() {
    let y = 
    {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```
此处用了一个语句块为y赋值。这个语句块也是表达式，因为最后一行返回了x+1的值。

请注意：**表达式不能包含分号**，否则它将成为语句。

此外，也可以像c++一样使用return来显式地返回值。

### 2.2.4 函数
基本结构：
```rs
fn add(i: InputType) -> ReturnType
{
    statement;
    returnValue
}
```

要点：
* 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -> {}
* 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
* 每个函数参数都需要标注类型

#### 参数
Rust是强类型语言，每个参数都要标识出具体类型。

#### 特殊返回类型
* 函数没有指定返回值，那么返回`()`
* 通过;结尾的语句也会返回一个`()`


* 感叹号`!`作为返回类型，则代表永不返回值。这种语法往往用在会导致程序崩溃的函数：
```rs
fn dead_end() -> {
    panic!("程序炸了");
}
```



### 课后练习笔记
